# 코어 자바스크립트

## 클래스 (Class)

> 상위의 클래스부터 먼저 정의되어야 하위 클래스, 인스턴스를 생성할 수 있음 

### 클래스 class

계급, 집단, 집합 <br>
공통적인 속성을 모아 한 데 묶은 덩어리 또는 명세 <br>
인스턴스들의 공통 속성을 모은 추상적인 개념

<br>

### 인스턴스 instance 

해당 클래스의 속성을 지닌 구체적인 객체들

> 🍲 음식 = `class`, 과일 클래스의 상위 클래스 = `superclass`   
> 🍎 과일 = `class`, 음식 클래스의 하위 클래스 = `subclass`   
> 🍓🍌🍊 배 사과 바나나 감 오렌지 = `인스턴스`

<br>

### 예시 

> [1, 2, 3] 배열 리터럴 생성 = new 연산자로 Array 생성자 함수를 호출한 결과   

> 📌 **클래스**
> 
> `Array 생성자 함수` 부분이 일반적인 개념상의 **클래스** 역할  
> `Array 생성자 함수`는 그 자체로 특별한 역할을 하기보다, new 연산자로 생성한 배열 객체의 기능을 정의하는데에 주력

> 📌 **인스턴스**
>
> 클래스를 통해 생성한 객체(배열 객체) -> **인스턴스**    
> 구체적인 데이터를 지니고 실제 코드상에서 동작을 수행하는 실체 중의 하나

![](../Images/인스턴스_설명.png)

<br><br>

## 클래스 

* 클래스 부분만 분리한 이미지

![](../Images/클래스_설명.png)

### 스태틱 메소드, 스태틱 프로퍼티  
  
프로토타입 프로퍼티에 할당되지 않고 **생성자 함수에 직접 할당되어있는 프로퍼티**    
생성자 함수를 new 연산자 없이 함수(객체)로서 호출할 때에만 의미가 있는 값  
해당 클래스 소속 인스턴스의 개별 동작이 아닌, 소속 여부 확인 등의 **공동체적 판단**을 필요로 할 때 활용     

<br>

### 프로토타입 메소드  

프로토타입 내부에 정의된 메소드   
줄여서 **메소드**라고 부름   
인스턴스에서 직접 활용 가능 

<br>

### 클래스와 인스턴스의 관계

스태틱 메소드와 프로토타입 메소드는 **인스턴스에서 직접 접근 가능 여부**가 다름 

* `스태틱 메소드` : 인스턴스에서 접근 불가 ❌, 생성자 함수 내부의 프로퍼티(스태틱 메소드)에 접근 불가능
  * 프로토타입의 constructor를 통해 우회는 가능하지만, 인스턴스를 this로 하려면 별도의 처리 필요
  * 우회하는 경우에도 제대로 동작하기를 기대하기는 어려움 
* `프로토타입 메소드` : 인스턴스에서 접근 가능 ✅, 인스턴스와 `[[prototype]]`으로 연결됨 

<br>

![](../Images/클래스_인스턴스_관계.png)

> 스태틱 메소드에서 제대로 된 결과를 얻으려면 생성자 함수에서 직접 접근해야 함

<br><br>

## 클래스 상속 (class inheritance)

'프로토타입의 constructor는 Employee'를 만드는 과정 예시

<br>

![슈퍼클래스_서브클래스](../Images/슈퍼클래스_서브클래스.png)

![클래스_상속_브릿지](../Images/클래스_상속_브릿지.png)



![브릿지_코드](../Images/브릿지_코드.png)

![브릿지_코드_결과](../Images/브릿지_코드_결과.png)

<br>

* ES5 시스템에서 클래스 상속을 구현하는 데에 자주 등장하는 패턴
* Bridge라는 함수는 매개체 역할만 하며, 실제 코드상에 영향 주지 않음 <br>

=> <strong>함수화</strong>를 통해 간단한 형태로 상속을 구현할 수 있다.

<br>

### 함수화

![](../Images/브릿지_함수화.png) 


ES6에서는 함수를 직접 만들어서 구현하지 않아도 자바스크립트 내장 명령으로 클래스 상속 구현이 가능하다.

<br>

### ES6

![](../Images/ES6_클래스_상속_구현.png)

class Person 만들고, Employee는 Person을 extends 해주면 된다.


