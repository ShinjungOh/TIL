# 스코프 

## 스코프(Scope)

### 개념 

변수의 유효범위  
참조 대상 식별자(identifier, 변수, 함수의 이름 등 어떤 대상을 다른 대상과 구분할 수 있는 유일한 이름)를 찾아내기 위한 규칙 

변수는 `전역` 또는 `코드 블록`(if, for, while, try/catch 등)이나 `함수 내`에 선언하며 코드 블록이나 함수는 중첩될 수 있음  
식별자는 자신이 어디에서 선언됐는지에 따라 자신이 유효한(다른 코드가 자신을 참조할 수 있는) 범위를 가짐 => 스코프   

* 전역에 선언된 변수 : 어디서든 참조 가능  
* 함수 내에서 선언된 변수 : 함수 내부에서만 참조할 수 있고, 그 함수 외부에서는 참조할 수 없음

> 🔖 스코프는 식별자 이름의 충돌을 방지  
> 스코프가 없다면 같은 식별자 이름은 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할 수 없음  
> Ex. 디렉토리가 없다면 같은 이름을 갖는 파일을 하나밖에 만들 수 없음 

<br>

### 구분

변수는 선언 위치(전역 또는 지역)에 의해 스코프를 가짐  

* 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수
* 지역(함수 내부)에서 선언된 변수는 지역 스코프를 갖는 지역 변수

#### 전역 스코프 (Global scope)

코드 어디서나 참조 가능 

#### 지역 스코프 (Local scope or Function-level scope)

함수 코드 블록이 만든 스코프  
함수 자신과 하위 함수에서만 참조 가능 


> 📌 모든 변수는 스코프를 가지며, 변수의 관점에서 스코프를 구분하는 2가지 경우 

#### 전역 변수 (Global variable)

전역에서 선언된 변수이며 어디서든 참조 가능

#### 지역 변수 (Local variable)

지역(함수) 내에서 선언된 변수  
그 지역과 그 지역의 하위 지역에서만 참조할 수 있음

<br><br>

## 자바스크립트 스코프의 특징

자바스크립트는 **함수 레벨 스코프**(function-level scope)를 따름 -> 타 언어와 다른 특징  
`함수 레벨 스코프`란, 함수 코드 블록 내에서 선언된 변수는 **함수 코드 블록 내에서만 유효**하고, 함수 외부에서는 유효하지 않다(참조할 수 없다)는 것  
ECMAScript 6에서 도입된 `let`을 사용하면 블록 레벨 스코프 사용 가능 

대부분의 C-family language는 **블록 레벨 스코프**(block-level scope)를 따름   
`블록 레벨 스코프`란, 코드 블록({…})내에서 유효한 스코프

> 🔎 `유효하다` = `참조(접근)할 수 있다`

### 예시 

#### ❌ var는 블록 스코프를 가지지 않음 

```js
var x = 0;
{
  var x = 1;
  console.log(x); // 1
}
console.log(x);   // 1
```

#### ✅ let, const는 블록 스코프를 가짐

```js
let y = 0;
{
  let y = 1;
  console.log(y); // 1
}
console.log(y);   // 0
```

<br><br>

## 전역 스코프(Global scope)

전역에 변수를 선언하면 이 변수는 어디서든지 참조할 수 있는 `전역 스코프`를 갖는 `전역 변수`가 됨  
`var` 키워드로 선언한 전역 변수는 전역 객체(Global Object) window의 프로퍼티


자바스크립트는 전역에 변수를 선언하기 쉬움 -> 전역 변수를 남발하는 문제 발생   
⚠️ 변수 이름이 중복될 수 있고, 의도치 않은 재할당으로 코드를 예측하기 어렵게 만들기 때문에 **전역 변수 사용을 피해야 함** 

### 비 블록 레벨 스코프(Non block-level scope)

함수 밖에서 선언된 변수(var)는 코드 블록 내에서 선언되었더라도 모두 전역 스코프를 가짐   

```js
if (true) {
  var x = 5;
}

console.log(x); // 5
```

<br><br>

## 함수 레벨 스코프(Function-level scope)

자바스크립트는 함수 레벨 스코프를 사용   

> 내부 함수에서는 외부에 접근 가능하지만, 함수 바깥에서는 내부 함수에 접근 불가  

* 내부함수는 전역변수, 상위 함수(외부 함수)에서 선언한 변수에 접근/변경 가능
* 함수 내에서 선언된 매개변수와 변수는 함수 외부에서는 유효하지 않음 

<br><br>

## 렉시컬 스코프

> 📌 함수의 상위 스코프가 무엇인지에 따라 결정됨   
> 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 **렉시컬 스코프**를 따름

### 프로그래밍 언어가 함수의 상위 스코프를 결정하는 두가지 방식  

1. `동적 스코프`(Dynamic scope) : 함수를 어디서 **호출**했는지에 따라 상위 스코프를 결정 
2. `렉시컬 스코프`(Lexical scope), 정적 스코프(Static scope) : 함수를 어디서 **선언**했는지에 따라 상위 스코프를 결정 

### 렉시컬 스코프 개념 

렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 **어디에 선언했는지**에 따라 결정   
자바스크립트는 렉시컬 스코프를 따르므로 **함수를 선언한 시점에 상위 스코프가 결정됨**  

함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않음   

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

<br><br>

## 암묵적 전역

선언하지 않은 식별자 y

foo 함수가 호출되면 자바스크립트 엔진은 변수 y에 값을 할당하기 위해 먼저 스코프 체인을 통해 선언된 변수인지 확인   
foo 함수의 스코프, 전역 스코프 어디에서도 변수 y의 선언을 찾을 수 없으므로 참조 에러가 발생해야 하지만   
자바스크립트 엔진은 y = 20을 `window.y = 20`으로 해석하여 프로퍼티를 동적 생성   
y는 전역 객체의 프로퍼티가 되어 전역 변수처럼 동작 => **암묵적 전역(implicit global)**

```js
const x = 10; // 전역 변수

function foo () {
  y = 20;  // 선언하지 않은 식별자
  console.log(x + y);
}

foo(); // 30
```

* y = 20이 실행되면 참조 에러가 발생할 것처럼 보이지만, 식별자 y는 마치 선언된 변수처럼 동작   
  -> 선언하지 않은 식별자에 값을 할당하면 **전역 객체의 프로퍼티**가 되기 때문
* y는 변수 선언 없이 전역 객체의 프로퍼티로 추가됨 -> y는 변수가 아님 => y는 변수 호이스팅이 발생하지 않음 
* 프로퍼티인 y는 delete 연산자로 삭제 가능
  * 전역 변수는 프로퍼티이지만 delete 연산자로 삭제할 수 없음 

<br><br>

## 최소한의 전역변수 사용

전역변수 사용을 최소화하는 방법

### 전역변수 객체 사용하기 

전역변수 사용을 위해 **전역변수 객체** 하나를 만들어 사용하기(더글라스 크락포드의 제안)

```js
const MYAPP = {};

MYAPP.student = {
    name: 'SJ',
    gender: 'female',
    age: 100
};

console.log(MYAPP.student.name);
```

<br>

### 즉시실행함수 이용하기

즉시 실행 함수(IIFE, Immediately-Invoked Function Expression) 사용  
전역변수를 만들지 않으므로 라이브러리 등에 자주 사용됨  
즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라짐

<br><br>

## 참고 사이트 

> https://poiemaweb.com/js-scope  
> https://poiemaweb.com/es6-block-scope  
> <더글라스 크락포드의 자바스크립트 핵심 가이드>
